import { Collection, Field } from '@/types';

const PRISMA_TYPE_MAPPING = {
	string: 'String',
	number: 'Int',
	boolean: 'Boolean',
	date: 'DateTime',
	objectId: 'String', // Prisma uses String for MongoDB ObjectIds
	array: 'String[]', // Default to String array
	mixed: 'Json',
} as const;

function generateFieldDefinition(
	field: Field,
	collections: Collection[]
): string {
	const { name, type, required, defaultValue, unique, index } = field;

	let fieldDef = `  ${name}`;
	let fieldType = '';
	let attributes: string[] = [];

	// Handle field type
	if (type === 'objectId' && field.ref) {
		// Find the referenced collection
		const refCollection = collections.find((col) => col.id === field.ref);
		const refName = refCollection ? refCollection.name : field.ref;
		fieldType = refName;
		attributes.push(`@relation(fields: [${name}], references: [id])`);
	} else if (type === 'array' && field.arrayType) {
		const arrayType =
			PRISMA_TYPE_MAPPING[
				field.arrayType as keyof typeof PRISMA_TYPE_MAPPING
			] || 'String';
		fieldType = `${arrayType}[]`;
	} else {
		fieldType =
			PRISMA_TYPE_MAPPING[type as keyof typeof PRISMA_TYPE_MAPPING] ||
			'String';
	}

	// Add optional/required modifier
	if (!required && type !== 'objectId') {
		fieldType += '?';
	}

	fieldDef += ` ${fieldType}`;

	// Add field attributes
	if (name === 'id') {
		attributes.push('@id @default(auto()) @map("_id") @db.ObjectId');
	} else if (unique) {
		attributes.push('@unique');
	}

	if (index && !unique) {
		attributes.push('@@index([' + name + '])');
	}

	if (defaultValue) {
		if (type === 'string') {
			attributes.push(`@default("${defaultValue}")`);
		} else if (type === 'date') {
			attributes.push('@default(now())');
		} else {
			attributes.push(`@default(${defaultValue})`);
		}
	}

	if (attributes.length > 0) {
		fieldDef += ` ${attributes.join(' ')}`;
	}

	return fieldDef;
}

export function generatePrismaSchema(
	collection: Collection,
	allCollections: Collection[],
	connections: any[] = []
): string {
	const { name, fields } = collection;

	const fieldDefinitions = fields
		.map((field) => generateFieldDefinition(field, allCollections))
		.join('\n');

	// Generate relation fields for references
	const relationFields = generateRelationFields(collection, allCollections);

	const schemaCode = `// Prisma schema for ${name}
// Generated by MongoDB Schema Designer

model ${name} {
${fieldDefinitions}
${relationFields ? '\n' + relationFields : ''}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("${name.toLowerCase()}")
}`;

	return schemaCode;
}

function generateRelationFields(
	collection: Collection,
	allCollections: Collection[]
): string {
	const relationFields: string[] = [];

	// Find fields that reference this collection
	allCollections.forEach((otherCollection) => {
		if (otherCollection.id === collection.id) return;

		otherCollection.fields.forEach((field) => {
			if (field.type === 'objectId' && field.ref === collection.id) {
				const relationName = `${otherCollection.name.toLowerCase()}s`;
				relationFields.push(
					`  ${relationName} ${otherCollection.name}[]`
				);
			}
		});
	});

	return relationFields.join('\n');
}
